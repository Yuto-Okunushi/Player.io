const WebSocket = require('ws');

const wss = new WebSocket.Server({ port: 8080 }); // クライアントコードのWS_URLと一致させる

const MAX_PLAYERS = 4;
let connectedClients = new Map(); // Map<WebSocket, { userId: string, animalId: number, status: string }>
let players = {}; // { userId: { animalId: number, status: string } }
let animalPool = [1, 2, 3, 4]; // 利用可能な動物ID
let gamePhase = "waiting_for_players"; // waiting_for_players, animal_reveal, action_select, discussion, result

let userIdCounter = 0;

console.log("WebSocketサーバーをポート8080で起動中...");

wss.on('connection', ws => {
    const userId = `user_${++userIdCounter}`;
    let assignedAnimalId = null;

    if (connectedClients.size < MAX_PLAYERS) {
        // 動物をランダムに割り当てる
        if (animalPool.length > 0) {
            const randomIndex = Math.floor(Math.random() * animalPool.length);
            assignedAnimalId = animalPool.splice(randomIndex, 1)[0];
        } else {
            // 動物が不足している場合の処理（例: すでに割り当てられた動物を再利用するか、エラーを返す）
            // 今回は単純化のため、4人を超えたら接続を拒否する想定
            ws.send(JSON.stringify({ type: "error", message: "定員オーバーです。" }));
            ws.close();
            return;
        }

        connectedClients.set(ws, { userId: userId, animalId: assignedAnimalId, status: "connected" });
        players[userId] = { animalId: assignedAnimalId, status: "connected" };

        console.log(`新しいクライアントが接続しました: ${userId}, 動物ID: ${assignedAnimalId}`);

        // クライアントにユーザーIDと割り当てられた動物を送信
        ws.send(JSON.stringify({ type: "user_assigned", userId: userId, animalId: assignedAnimalId }));

        // 全クライアントにプレイヤーの状態を更新
        broadcastPlayersUpdate();

        // 4人揃ったらゲーム開始
        if (connectedClients.size === MAX_PLAYERS) {
            console.log("全プレイヤーが揃いました。ゲームを開始します。");
            gamePhase = "animal_reveal";
            setTimeout(() => {
                broadcast({ type: "game_start" });
                broadcastGamePhase("action_select");
            }, 3000); // 動物表示の猶予
        } else {
            console.log(`現在のプレイヤー数: <span class="math-inline">\{connectedClients\.size\}/</span>{MAX_PLAYERS}`);
        }

    } else {
        console.log("定員オーバーのため、接続を拒否しました。");
        ws.send(JSON.stringify({ type: "error", message: "定員オーバーです。後ほどお試しください。" }));
        ws.close();
    }

    ws.on('message', message => {
        console.log(`メッセージを受信しました (${userId}): ${message}`);
        try {
            const data = JSON.parse(message);
            if (data.type === "ready") {
                // クライアントが「OK」ボタンを押して準備ができたことを通知
                const clientInfo = connectedClients.get(ws);
                if (clientInfo) {
                    clientInfo.status = "ready";
                    players[clientInfo.userId].status = "ready";
                    console.log(`${clientInfo.userId} が準備完了しました。`);
                    broadcastPlayersUpdate();

                    // 全員が準備完了したら次のフェーズへ
                    if (Object.values(players).every(p => p.status === "ready")) {
                        console.log("全プレイヤーが準備完了しました。アクション選択フェーズへ。");
                        broadcastGamePhase("action_select");
                    }
                }
            } else if (data.type === "action") {
                // アクションを受信
                const clientInfo = connectedClients.get(ws);
                if (clientInfo) {
                    console.log(`${clientInfo.userId} がアクション ${data.actionId} を選択しました。`);
                    // アクションをサーバー側で処理し、必要に応じて全プレイヤーに通知
                    // 例: 全プレイヤーがアクションを選択したら、議論フェーズへ

                    // 仮の実装: アクションを受け取ったら、議論フェーズに移行する
                    // 実際には、全ユーザーのアクションを収集し、何らかのロジックに基づいて次のフェーズを決定します
                    broadcastGamePhase("discussion"); 
                    // アクション選択後は、クライアント側のボタンを無効にするなどの処理が必要
                }
            }
        } catch (e) {
            // 古い形式のメッセージハンドリングをサーバー側でも考慮する場合はここに追加
            console.error("JSONパースエラーまたは不明なメッセージ形式:", e);
            // テスト用のレガシーメッセージ処理
            if (message.toString().trim() === "ok") {
                const clientInfo = connectedClients.get(ws);
                if (clientInfo) {
                    clientInfo.status = "ready";
                    players[clientInfo.userId].status = "ready";
                    broadcastPlayersUpdate();
                    if (Object.values(players).every(p => p.status === "ready")) {
                        broadcastGamePhase("action_select");
                    }
                }
            }
        }
    });

    ws.on('close', () => {
        const clientInfo = connectedClients.get(ws);
        if (clientInfo) {
            console.log(`クライアントが切断しました: ${clientInfo.userId}`);
            connectedClients.delete(ws);
            delete players[clientInfo.userId];
            // 動物をプールに戻す（オプション）
            animalPool.push(clientInfo.animalId);
            broadcastPlayersUpdate();
        }
    });

    ws.on('error', error => {
        console.error(`WebSocketエラー (${userId}):`, error);
    });
});

function broadcast(message) {
    wss.clients.forEach(client => {
        if (client.readyState === WebSocket.OPEN) {
            client.send(JSON.stringify(message));
        }
    });
}

function broadcastPlayersUpdate() {
    // 現在のプレイヤー情報を整形して送信
    const currentPlayers = {};
    for (const [ws, info] of connectedClients) {
        currentPlayers[info.userId] = {
            animalId: info.animalId,
            status: info.status
        };
    }
    broadcast({ type: "players_update", players: currentPlayers });
}

function broadcastGamePhase(phase, data = {}) {
    gamePhase = phase;
    broadcast({ type: "game_phase", phase: phase, data: data });
}
